{"version":3,"file":"908.mjs","sources":["webpack://example-esm/./node_modules/graphql/utilities/findBreakingChanges.mjs","webpack://example-esm/./node_modules/graphql/jsutils/isAsyncIterable.mjs","webpack://example-esm/./node_modules/graphql/execution/subscribe.mjs","webpack://example-esm/./node_modules/graphql/execution/mapAsyncIterator.mjs","webpack://example-esm/./node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs","webpack://example-esm/./node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs","webpack://example-esm/./node_modules/graphql/utilities/getOperationRootType.mjs","webpack://example-esm/./node_modules/graphql/utilities/introspectionFromSchema.mjs","webpack://example-esm/./node_modules/graphql/utilities/buildClientSchema.mjs","webpack://example-esm/./node_modules/graphql/utilities/concatAST.mjs","webpack://example-esm/./node_modules/graphql/utilities/separateOperations.mjs","webpack://example-esm/./node_modules/graphql/utilities/stripIgnoredCharacters.mjs","webpack://example-esm/./node_modules/graphql/utilities/assertValidName.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nimport { sortValueNode } from './sortValueNode.mjs';\nvar BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] =\n    'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] =\n    'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] =\n    'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] =\n    'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] =\n    'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\n\nexport { BreakingChangeType };\nvar DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] =\n    'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] =\n    'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\n\nexport { DangerousChangeType };\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in BreakingChangeType,\n  );\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in DangerousChangeType,\n  );\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema),\n  ];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(\n    oldSchema.getDirectives(),\n    newSchema.getDirectives(),\n  );\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`,\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`,\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`,\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(\n    Object.values(oldSchema.getTypeMap()),\n    Object.values(newSchema.getTypeMap()),\n  );\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType)\n        ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.`\n        : `${oldType.name} was removed.`,\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description:\n          `${oldType.name} changed from ` +\n          `${typeKindName(oldType)} to ${typeKindName(newType)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`,\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`,\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldArg.type,\n      newArg.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` +\n          `${String(oldArg.type)} to ${String(newArg.type)}.`,\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`,\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`,\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      (isListType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from nullable to non-null of the same underlying type is safe\n      (isNonNullType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (\n      isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)\n    );\n  }\n\n  return (\n    // if they're both named types, see if their names are equivalent\n    (isNamedType(newType) && oldType.name === newType.name) || // moving from nullable to non-null of the same underlying type is safe\n    (isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (\n      isListType(newType) &&\n      isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      (isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from non-null to nullable of the same underlying type is safe\n      (!isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType))\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  const ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  return print(sortValueNode(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap(oldArray, ({ name }) => name);\n  const newMap = keyMap(newArray, ({ name }) => name);\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed,\n  };\n}\n","/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * implementing a `Symbol.asyncIterator` method.\n */\nexport function isAsyncIterable(maybeAsyncIterable) {\n  return (\n    typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0\n      ? void 0\n      : maybeAsyncIterable[Symbol.asyncIterator]) === 'function'\n  );\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isAsyncIterable } from '../jsutils/isAsyncIterable.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { collectFields } from './collectFields.mjs';\nimport {\n  assertValidExecutionArguments,\n  buildExecutionContext,\n  buildResolveInfo,\n  execute,\n  getFieldDef,\n} from './execute.mjs';\nimport { mapAsyncIterator } from './mapAsyncIterator.mjs';\nimport { getArgumentValues } from './values.mjs';\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\nexport async function subscribe(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const resultOrStream = await createSourceEventStream(args);\n\n  if (!isAsyncIterable(resultOrStream)) {\n    return resultOrStream;\n  } // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  const mapSourceToResponse = (payload) =>\n    execute({ ...args, rootValue: payload }); // Map every source value to a ExecutionResult value as described above.\n\n  return mapAsyncIterator(resultOrStream, mapSourceToResponse);\n}\n\nfunction toNormalizedArgs(args) {\n  const firstArg = args[0];\n\n  if (firstArg && 'document' in firstArg) {\n    return firstArg;\n  }\n\n  return {\n    schema: firstArg,\n    // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    subscribeFieldResolver: args[6],\n  };\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\nexport async function createSourceEventStream(...rawArgs) {\n  const args = toNormalizedArgs(rawArgs);\n  const { schema, document, variableValues } = args; // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  }\n\n  try {\n    const eventStream = await executeSubscription(exeContext); // Assert field returned an event stream, otherwise yield an error.\n\n    if (!isAsyncIterable(eventStream)) {\n      throw new Error(\n        'Subscription field must return Async Iterable. ' +\n          `Received: ${inspect(eventStream)}.`,\n      );\n    }\n\n    return eventStream;\n  } catch (error) {\n    // If it GraphQLError, report it as an ExecutionResult, containing only errors and no data.\n    // Otherwise treat the error as a system-class error and re-throw it.\n    if (error instanceof GraphQLError) {\n      return {\n        errors: [error],\n      };\n    }\n\n    throw error;\n  }\n}\n\nasync function executeSubscription(exeContext) {\n  const { schema, fragments, operation, variableValues, rootValue } =\n    exeContext;\n  const rootType = schema.getSubscriptionType();\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      'Schema is not configured to execute subscription operation.',\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = collectFields(\n    schema,\n    fragments,\n    variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const [responseName, fieldNodes] = [...rootFields.entries()][0];\n  const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    const fieldName = fieldNodes[0].name.value;\n    throw new GraphQLError(\n      `The subscription field \"${fieldName}\" is not defined.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  const path = addPath(undefined, responseName, rootType.name);\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    rootType,\n    path,\n  );\n\n  try {\n    var _fieldDef$subscribe;\n\n    // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n    // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    const resolveFn =\n      (_fieldDef$subscribe = fieldDef.subscribe) !== null &&\n      _fieldDef$subscribe !== void 0\n        ? _fieldDef$subscribe\n        : exeContext.subscribeFieldResolver;\n    const eventStream = await resolveFn(rootValue, args, contextValue, info);\n\n    if (eventStream instanceof Error) {\n      throw eventStream;\n    }\n\n    return eventStream;\n  } catch (error) {\n    throw locatedError(error, fieldNodes, pathToArray(path));\n  }\n}\n","/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterator(iterable, callback) {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  async function mapResult(result) {\n    if (result.done) {\n      return result;\n    }\n\n    try {\n      return {\n        value: await callback(result.value),\n        done: false,\n      };\n    } catch (error) {\n      /* c8 ignore start */\n      // FIXME: add test case\n      if (typeof iterator.return === 'function') {\n        try {\n          await iterator.return();\n        } catch (_e) {\n          /* ignore error */\n        }\n      }\n\n      throw error;\n      /* c8 ignore stop */\n    }\n  }\n\n  return {\n    async next() {\n      return mapResult(await iterator.next());\n    },\n\n    async return() {\n      // If iterator.return() does not exist, then type R must be undefined.\n      return typeof iterator.return === 'function'\n        ? mapResult(await iterator.return())\n        : {\n            value: undefined,\n            done: true,\n          };\n    },\n\n    async throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return mapResult(await iterator.throw(error));\n      }\n\n      throw error;\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n","import { invariant } from '../../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType, isInputObjectType } from '../../../type/definition.mjs';\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason =\n        fieldDef === null || fieldDef === void 0\n          ? void 0\n          : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason =\n        argDef === null || argDef === void 0\n          ? void 0\n          : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(\n            new GraphQLError(\n              `Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          (parentType != null && fieldDef != null) || invariant(false);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason =\n          inputFieldDef === null || inputFieldDef === void 0\n            ? void 0\n            : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(\n            new GraphQLError(\n              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason =\n        enumValueDef === null || enumValueDef === void 0\n          ? void 0\n          : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType } from '../../../type/definition.mjs';\nimport { isIntrospectionType } from '../../../type/introspection.mjs';\n\n/**\n * Prohibit introspection queries\n *\n * A GraphQL document is only valid if all fields selected are not fields that\n * return an introspection type.\n *\n * Note: This rule is optional and is not part of the Validation section of the\n * GraphQL Specification. This rule effectively disables introspection, which\n * does not reflect best practices and should only be done if absolutely necessary.\n */\nexport function NoSchemaIntrospectionCustomRule(context) {\n  return {\n    Field(node) {\n      const type = getNamedType(context.getType());\n\n      if (type && isIntrospectionType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `GraphQL introspection has been disabled, but the requested query contained the field \"${node.name.value}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../error/GraphQLError.mjs';\n\n/**\n * Extracts the root type of the operation from the schema.\n *\n * @deprecated Please use `GraphQLSchema.getRootType` instead. Will be removed in v17\n */\nexport function getOperationRootType(schema, operation) {\n  if (operation.operation === 'query') {\n    const queryType = schema.getQueryType();\n\n    if (!queryType) {\n      throw new GraphQLError(\n        'Schema does not define the required query root type.',\n        {\n          nodes: operation,\n        },\n      );\n    }\n\n    return queryType;\n  }\n\n  if (operation.operation === 'mutation') {\n    const mutationType = schema.getMutationType();\n\n    if (!mutationType) {\n      throw new GraphQLError('Schema is not configured for mutations.', {\n        nodes: operation,\n      });\n    }\n\n    return mutationType;\n  }\n\n  if (operation.operation === 'subscription') {\n    const subscriptionType = schema.getSubscriptionType();\n\n    if (!subscriptionType) {\n      throw new GraphQLError('Schema is not configured for subscriptions.', {\n        nodes: operation,\n      });\n    }\n\n    return subscriptionType;\n  }\n\n  throw new GraphQLError(\n    'Can only have query, mutation and subscription operations.',\n    {\n      nodes: operation,\n    },\n  );\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nimport { parse } from '../language/parser.mjs';\nimport { executeSync } from '../execution/execute.mjs';\nimport { getIntrospectionQuery } from './getIntrospectionQuery.mjs';\n/**\n * Build an IntrospectionQuery from a GraphQLSchema\n *\n * IntrospectionQuery is useful for utilities that care about type and field\n * relationships, but do not need to traverse through those relationships.\n *\n * This is the inverse of buildClientSchema. The primary use case is outside\n * of the server context, for instance when doing schema comparisons.\n */\n\nexport function introspectionFromSchema(schema, options) {\n  const optionsWithDefaults = {\n    specifiedByUrl: true,\n    directiveIsRepeatable: true,\n    schemaDescription: true,\n    inputValueDeprecation: true,\n    oneOf: true,\n    ...options,\n  };\n  const document = parse(getIntrospectionQuery(optionsWithDefaults));\n  const result = executeSync({\n    schema,\n    document,\n  });\n  (!result.errors && result.data) || invariant(false);\n  return result.data;\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { parseValue } from '../language/parser.mjs';\nimport {\n  assertInterfaceType,\n  assertNullableType,\n  assertObjectType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isInputType,\n  isOutputType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  (isObjectLike(introspection) && isObjectLike(introspection.__schema)) ||\n    devAssert(\n      false,\n      `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect(\n        introspection,\n      )}.`,\n    ); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = keyValMap(\n    schemaIntrospection.types,\n    (typeIntrospection) => typeIntrospection.name,\n    (typeIntrospection) => buildType(typeIntrospection),\n  ); // Include standard types only if they are used.\n\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  const queryType = schemaIntrospection.queryType\n    ? getObjectType(schemaIntrospection.queryType)\n    : null;\n  const mutationType = schemaIntrospection.mutationType\n    ? getObjectType(schemaIntrospection.mutationType)\n    : null;\n  const subscriptionType = schemaIntrospection.subscriptionType\n    ? getObjectType(schemaIntrospection.subscriptionType)\n    : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives\n    ? schemaIntrospection.directives.map(buildDirective)\n    : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\n        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`,\n      );\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = inspect(type);\n    throw new Error(\n      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`,\n    );\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL,\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (\n      implementingIntrospection.interfaces === null &&\n      implementingIntrospection.kind === TypeKind.INTERFACE\n    ) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\n        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`,\n      );\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection),\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection),\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\n        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType),\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\n        `Introspection result missing enumValues: ${enumIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(\n        enumIntrospection.enumValues,\n        (valueIntrospection) => valueIntrospection.name,\n        (valueIntrospection) => ({\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason,\n        }),\n      ),\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\n        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),\n      isOneOf: inputObjectIntrospection.isOneOf,\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\n        `Introspection result missing fields: ${inspect(typeIntrospection)}.`,\n      );\n    }\n\n    return keyValMap(\n      typeIntrospection.fields,\n      (fieldIntrospection) => fieldIntrospection.name,\n      buildField,\n    );\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide output type for fields, but received: ${typeStr}.`,\n      );\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\n        `Introspection result missing field args: ${fieldIntrospectionStr}.`,\n      );\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args),\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(\n      inputValueIntrospections,\n      (inputValue) => inputValue.name,\n      buildInputValue,\n    );\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide input type for arguments, but received: ${typeStr}.`,\n      );\n    }\n\n    const defaultValue =\n      inputValueIntrospection.defaultValue != null\n        ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type)\n        : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason,\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive args: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args),\n    });\n  }\n}\n","import { Kind } from '../language/kinds.mjs';\n/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n */\n\nexport function concatAST(documents) {\n  const definitions = [];\n\n  for (const doc of documents) {\n    definitions.push(...doc.definitions);\n  }\n\n  return {\n    kind: Kind.DOCUMENT,\n    definitions,\n  };\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(\n          definitionNode.selectionSet,\n        );\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(\n        (node) =>\n          node === operation ||\n          (node.kind === Kind.FRAGMENT_DEFINITION &&\n            dependencies.has(node.name.value)),\n      ),\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    },\n  });\n  return dependencies;\n}\n","import { printBlockString } from '../language/blockString.mjs';\nimport { isPunctuatorTokenKind, Lexer } from '../language/lexer.mjs';\nimport { isSource, Source } from '../language/source.mjs';\nimport { TokenKind } from '../language/tokenKind.mjs';\n/**\n * Strips characters that are not significant to the validity or execution\n * of a GraphQL document:\n *   - UnicodeBOM\n *   - WhiteSpace\n *   - LineTerminator\n *   - Comment\n *   - Comma\n *   - BlockString indentation\n *\n * Note: It is required to have a delimiter character between neighboring\n * non-punctuator tokens and this function always uses single space as delimiter.\n *\n * It is guaranteed that both input and output documents if parsed would result\n * in the exact same AST except for nodes location.\n *\n * Warning: It is guaranteed that this function will always produce stable results.\n * However, it's not guaranteed that it will stay the same between different\n * releases due to bugfixes or changes in the GraphQL specification.\n *\n * Query example:\n *\n * ```graphql\n * query SomeQuery($foo: String!, $bar: String) {\n *   someField(foo: $foo, bar: $bar) {\n *     a\n *     b {\n *       c\n *       d\n *     }\n *   }\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * query SomeQuery($foo:String!$bar:String){someField(foo:$foo bar:$bar){a b{c d}}}\n * ```\n *\n * SDL example:\n *\n * ```graphql\n * \"\"\"\n * Type description\n * \"\"\"\n * type Foo {\n *   \"\"\"\n *   Field description\n *   \"\"\"\n *   bar: String\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * \"\"\"Type description\"\"\" type Foo{\"\"\"Field description\"\"\" bar:String}\n * ```\n */\n\nexport function stripIgnoredCharacters(source) {\n  const sourceObj = isSource(source) ? source : new Source(source);\n  const body = sourceObj.body;\n  const lexer = new Lexer(sourceObj);\n  let strippedBody = '';\n  let wasLastAddedTokenNonPunctuator = false;\n\n  while (lexer.advance().kind !== TokenKind.EOF) {\n    const currentToken = lexer.token;\n    const tokenKind = currentToken.kind;\n    /**\n     * Every two non-punctuator tokens should have space between them.\n     * Also prevent case of non-punctuator token following by spread resulting\n     * in invalid token (e.g. `1...` is invalid Float token).\n     */\n\n    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);\n\n    if (wasLastAddedTokenNonPunctuator) {\n      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {\n        strippedBody += ' ';\n      }\n    }\n\n    const tokenBody = body.slice(currentToken.start, currentToken.end);\n\n    if (tokenKind === TokenKind.BLOCK_STRING) {\n      strippedBody += printBlockString(currentToken.value, {\n        minimize: true,\n      });\n    } else {\n      strippedBody += tokenBody;\n    }\n\n    wasLastAddedTokenNonPunctuator = isNonPunctuator;\n  }\n\n  return strippedBody;\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { assertName } from '../type/assertName.mjs';\n/* c8 ignore start */\n\n/**\n * Upholds the spec rules about naming.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function assertValidName(name) {\n  const error = isValidNameError(name);\n\n  if (error) {\n    throw error;\n  }\n\n  return name;\n}\n/**\n * Returns an Error if a name is invalid.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function isValidNameError(name) {\n  typeof name === 'string' || devAssert(false, 'Expected name to be a string.');\n\n  if (name.startsWith('__')) {\n    return new GraphQLError(\n      `Name \"${name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n    );\n  }\n\n  try {\n    assertName(name);\n  } catch (error) {\n    return error;\n  }\n}\n/* c8 ignore stop */\n"],"names":["BreakingChangeType","DangerousChangeType","isAsyncIterable","maybeAsyncIterable","Symbol","asyncIterator","args","arguments","length","resultOrStream","createSourceEventStream","mapAsyncIterator","iterable","callback","iterator","mapResult","result","done","value","error","return","_e","next","undefined","throw","payload","rootValue","rawArgs","toNormalizedArgs","firstArg","schema","document","contextValue","variableValues","operationName","subscribeFieldResolver","exeContext","errors","eventStream","executeSubscription","Error","fragments","operation","rootType","getSubscriptionType","nodes","responseName","fieldNodes","rootFields","selectionSet","entries","fieldDef","fieldName","name","path","info","_fieldDef$subscribe","resolveFn","subscribe","NoDeprecatedCustomRule","context","Field","node","getFieldDef","deprecationReason","parentType","getParentType","reportError","Argument","argDef","getArgument","directiveDef","getDirective","ObjectField","inputObjectDef","getParentInputType","inputFieldDef","getFields","EnumValue","enumValueDef","getEnumValue","enumTypeDef","getInputType","NoSchemaIntrospectionCustomRule","type","getType","getOperationRootType","queryType","getQueryType","mutationType","getMutationType","subscriptionType","introspectionFromSchema","options","optionsWithDefaults","specifiedByUrl","directiveIsRepeatable","schemaDescription","inputValueDeprecation","oneOf","data","buildClientSchema","introspection","__schema","schemaIntrospection","typeMap","types","typeIntrospection","buildType","kind","buildScalarDef","scalarIntrospection","description","specifiedByURL","buildObjectDef","objectIntrospection","interfaces","buildImplementationsList","fields","buildFieldDefMap","buildInterfaceDef","interfaceIntrospection","buildUnionDef","unionIntrospection","possibleTypes","unionIntrospectionStr","map","getObjectType","buildEnumDef","enumIntrospection","enumValues","enumIntrospectionStr","values","valueIntrospection","buildInputObjectDef","inputObjectIntrospection","inputFields","inputObjectIntrospectionStr","buildInputValueDefMap","isOneOf","typeStr","stdType","directives","directiveIntrospection","directiveIntrospectionStr","locations","isRepeatable","slice","query","mutation","subscription","Object","assumeValid","typeRef","itemRef","ofType","nullableRef","nullableType","getNamedType","typeName","getInterfaceType","implementingIntrospection","implementingIntrospectionStr","fieldIntrospection","buildField","fieldIntrospectionStr","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","concatAST","documents","definitions","doc","push","separateOperations","documentAST","operations","depGraph","create","definitionNode","collectDependencies","separatedDocumentASTs","dependencies","Set","fragmentName","collectTransitiveDependencies","collected","fromName","has","add","immediateDeps","toName","filter","FragmentSpread","stripIgnoredCharacters","source","sourceObj","body","lexer","strippedBody","wasLastAddedTokenNonPunctuator","advance","T","currentToken","token","tokenKind","isNonPunctuator","tokenBody","start","end","minimize","assertValidName","isValidNameError","startsWith","findBreakingChanges","oldSchema","newSchema","findSchemaChanges","change","findDangerousChanges","findTypeChanges","schemaChanges","typesDiff","diff","getTypeMap","oldType","removed","TYPE_REMOVED","newType","persisted","findEnumTypeChanges","valuesDiff","getValues","newValue","added","VALUE_ADDED_TO_ENUM","oldValue","VALUE_REMOVED_FROM_ENUM","findUnionTypeChanges","possibleTypesDiff","getTypes","newPossibleType","TYPE_ADDED_TO_UNION","oldPossibleType","TYPE_REMOVED_FROM_UNION","findInputObjectTypeChanges","fieldsDiff","newField","REQUIRED_INPUT_FIELD_ADDED","OPTIONAL_INPUT_FIELD_ADDED","oldField","FIELD_REMOVED","isChangeSafeForInputObjectFieldOrFieldArg","FIELD_CHANGED_KIND","String","findFieldChanges","findImplementedInterfacesChanges","constructor","TYPE_CHANGED_KIND","typeKindName","findDirectiveChanges","directivesDiff","getDirectives","oldDirective","DIRECTIVE_REMOVED","newDirective","argsDiff","newArg","REQUIRED_DIRECTIVE_ARG_ADDED","oldArg","DIRECTIVE_ARG_REMOVED","location","DIRECTIVE_REPEATABLE_REMOVED","includes","DIRECTIVE_LOCATION_REMOVED","interfacesDiff","getInterfaces","newInterface","IMPLEMENTED_INTERFACE_ADDED","oldInterface","IMPLEMENTED_INTERFACE_REMOVED","findArgChanges","ARG_REMOVED","ARG_DEFAULT_VALUE_CHANGE","oldValueStr","stringifyValue","newValueStr","ARG_CHANGED_KIND","REQUIRED_ARG_ADDED","OPTIONAL_ARG_ADDED","isChangeSafeForObjectOrInterfaceField","ast","oldArray","newArray","oldMap","newMap","oldItem","newItem"],"mappings":"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"}